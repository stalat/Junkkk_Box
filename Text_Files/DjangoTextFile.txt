Django is a python framework:
        To install the Django say:
                sudo pip install django==version
                sudo pip install django==1.7.1

To check which version of Django is installed
                python -c "import django;print(django.get_version())"

For the very first application Database configuration, application specific settings are needed; That can be done by this command; just go to your Project folder and:
                django-admin.py startproject mysite


It'll create the folders as follows:
                Mysite/
                    manage.py
                    mysite/
                        __init__.py
                        urls.py
                        wsgi.py
                        settings.py

In settings.py file; All the settings are listed and can be used to configure database and we need to change the ENGINE section of the DATABASE dictionary as per the db chosen by us:
                DATABASES = {
                            'default': {
                                        'ENGINE': 'django.db.backends.sqlite3',
                                        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
                                       }
                            }

for postgress: 'django.db.backends.postgresql_psycopg2'

    DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql_psycopg2',
        'NAME': 'mydatabase',
        'USER': 'mydatabaseuser',
        'PASSWORD': 'mypassword',
        'HOST': '127.0.0.1',
        'PORT': '5432',
                }
               }

for mysql:     'django.db.backends.mysql'
for sqlite3:   'django.db.backends.sqlite3'
for oracle:    'django.db.backends.oracle'

MongoDB configuration:
    DATABASES = {
    'default': {
        'ENGINE': 'django_mongodb_engine',
        'NAME': 'mydatabase',
        'USER': '',
        'PASSWORD': '',
        'HOST': 'localhost',
        'PORT': '27017',
        'SUPPORTS_TRANSACTIONS': False,
                },
               }

It will create the mysqlite db file:
        python manage.py migrate

        In manage.py file; We've a os.environ variable In which we can set the DJANGO_SETINGS_MODULE as the setting of my own project as:
                import os;os.environ.set_default("DJANGO_SETINGS_MODULE", ' mysite.settings')

    The migrate command looks at the installed_apps setting and creates all necessary db tables acc. to db settings in mysql/settings.py
    MIGRATE functionallity come in django_1.7; Whenever we make changes in our models They need to be reflected in the database schema So MIGRATE do this.

    We make the changes in our models and makemigration command will package up our model changes into individual migration files and migration will apply these
    changes to Database Schema.[Updating your DB schema accn. to the latest change--GITHUB]
    For better understanding of Migrations, let's take an example;
        We already have a db schema and we make some changes to our model file So after performing the migrations on a file, the basic functionallity is like:
            
               1. Creating a new table with the new schema
               2. Copying the data across
               3. Dropping the old table
               4. Renaming the new table to match the original name

    When we first run the migrate command it creates the file under app_name/migrations directory and when without changing if migration is performed again;
    It won't do anything, So by default Django never runs the migrate command over the same database.
    For each migration that will ran; a new row is inserted into the table for the track of migrations happened.
    We can also undo all the migrations done on an app by firing this command:
        ./manage.py migrate historical_data zero

    Everytime I change the model file and makemirations over manage.py file; It'll create a new migraion file under migrations folder
    Instead of Zero we can also give other value so migration will be rolled back to that particular migrations.
    app_name/migrations/0001_initial.py is the file where the migration code is generated

                MODELS.PY:
                        from django.db import models

                        # Create your models here.
                        class Question(models.Model):                           #Question and Choie will be the class name
                            question_text = models.CharField(max_length=200)    #quetion_txt and pub_date will be the columns for this table
                            pub_date = models.DateTimeField('date published')


                        class Choice(models.Model):
                            question = models.ForeignKey(Question)
                            choice_text = models.CharField(max_length=200)
                            votes = models.IntegerField(default=0)
    
    For this model file; The migration code has been generated and that code is as follows:

                        from __future__ import unicode_literals

                        from django.db import models, migrations


                        class Migration(migrations.Migration):

                            dependencies = [
                            ]

                            operations = [
                                migrations.CreateModel(
                                    name='Choice',
                                    fields=[
                                        ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),
                                        ('choice_text', models.CharField(max_length=200)),
                                        ('votes', models.IntegerField(default=0)),
                                    ],
                                    options={
                                    },
                                    bases=(models.Model,),
                                ),
                                migrations.CreateModel(
                                    name='Question',
                                    fields=[
                                        ('id', models.AutoField(verbose_name='ID', serialize=False, auto_created=True, primary_key=True)),
                                        ('question_text', models.CharField(max_length=200)),
                                        ('pub_date', models.DateTimeField(verbose_name='date published')),
                                    ],
                                    options={
                                    },
                                    bases=(models.Model,),
                                ),
                                migrations.AddField(
                                    model_name='choice',
                                    name='question',
                                    field=models.ForeignKey(to='polls.Question'),
                                    preserve_default=True,
                                ),
                            ]


To check whether the server is running or not
        python manage.py runserver

and then check for http://127.0.0.1:8000/ on browser that will show me the welcome page for Django because in settings.py DEBUG=TRUE is set.
        We can manually change the port while giving the runserver command.

Now; We can say our project is ready and can start creating applications; Now need to worry about creating directories
        $ python manage.py startapp polls

It'll create the folders as follows:
        polls/
            admin.py
            __init__.py
            migrations/
                models.py
                views.py
                tests.py


We'll try to start our project by first writing the code in models.py file as:
        
        from django.db import models
        # Create your models here.
        class Question(models.Model):
            question_text = models.CharField(max_length=200)
            pub_date = models.DateTimeField('date published')

        class Choice(models.Model):
            question = models.ForeignKey(Question)
            choice_text = models.CharField(max_length=200)
            votes = models.IntegerField(default=0)

Here; django will understand what type of varaiable it is by looking as CharField/DateTimeField/IntegerField.
Django apps are pluggable: I can use an app in multiple project

As now with the project; I need to attach my app So In settings.py with INSTALLED_APPS dictionary; I'll add 'polls' (app_name) also.
run the following command as:
        python manage.py makemigrations polls

By running migrations; We're telling django that we've made some changes to our models and I'd like changes to be stored as a Migration.

Migrations are how Django stores changes to our models

This command will take the migrations and will returns the sql acc. to the Migrations defined
        python manage.py sqlmigrate polls 0001

    After running this command I got this kind of output on terminal
    polls -- apllication name
    question -- model name
    choice -- model name


                                BEGIN;
                                CREATE TABLE polls_question (
                                    "id" serial NOT NULL PRIMARY KEY,
                                    "question_text" varchar(200) NOT NULL,
                                    "pub_date" timestamp with time zone NOT NULL
                                );

                                CREATE TABLE polls_choice (
                                    "id" serial NOT NULL PRIMARY KEY,
                                    "question_id" integer NOT NULL,
                                    "choice_text" varchar(200) NOT NULL,
                                    "votes" integer NOT NULL
                                );

                                CREATE INDEX polls_choice_7aa0f6ee ON "polls_choice" ("question_id");

                                ALTER TABLE "polls_choice"
                                  ADD CONSTRAINT polls_choice_question_id_246c99a640fbbd72_fk_polls_question_id
                                    FOREIGN KEY ("question_id")
                                    REFERENCES "polls_question" ("id")
                                    DEFERRABLE INITIALLY DEFERRED;
                                COMMIT;

Django apps are pluggable so we can use any app in multiple projects.

                                python manage.py check

        this checks for any problems in your project without making migrations or touching the database


    Change your models (in models.py).
    $ python manage.py makemigrations to create migrations for those changes
    $ Run python manage.py migrate to apply those changes to the database.

Django takes all the migrations that havn't been applied, Django keeps track which ones are applied by special table called django_migrations.

Playing with the API:
    We can directly open the python shell by simply typing python but We use this command to invoke the Python shell
                    $ python manage.py shell

    Because manage.py set the DJANGO_SETTINGS_MODULE environment into mysite.settings #check manage.py file

We can now insert the values in the database we created

        from polls.models import Question, Choice
        Question.objects.all()
        from django.utils import timezone
        q = Question(question_text="What's new?", pub_date=timezone.now())
        q.save()
        q.question_text         #will give "What's new?"
        q.pub_date              #datetime.datetime(2012, 2, 26, 13, 0, 0, 775217, tzinfo=<UTC>)
        q.question_text = "What's up?"
        q.save()
        Question.objects.all()


Any number of objects I can create by the same method and they'll be listed as:
        [<Question: Talat>, <Question: Hello Talat>, <Question: Hello Talat>, <Question: This is first Object>, <Question: This is first Object>, <Question: This is first Object>]

        In case I want to look only for a single object I can do this by:
                Question.objects.filter(id=1)                   #id= index for Objects
                Question.objects.filter(question_text='Hello Talat')
                Question.objects.filter(question_text__startswith = 'Hello')
                Question.objects.filter(pub_date__year = timezone.now().year)                        
        
        If I want to get the object then say:
                Question.objects.get(id=2)
                Question.objects.get(pk=1)                      #In case of a primary key
        
        Can I delete the object??? Yes, I can
                t=Question.objects.get(id=1)
                t.delete()


Time to create the admin panel for Website, To handle the admin panel; I'll have to create superuser
		python manage.py createsuperuser

	It'll be asking about email and password after that It'll create the superuser who can login to administrator panel.
	Run the server like:
		python manage.py runserver port_no


	What If I want my polls application to be modifiable in the admin panel(browser).
		polls/admin.py
			from django.contrib import admin
			from polls.models import Question

			admin.site.register(Question)

	By registering Question model with admin.site.register(Question), Django was able to construct a default form representation,
	Often, I'll have to change how the admin form looks and works; This I can do by replacing admin.site.register(Question) line by this:

		poll/admin.py
			from django.contrib import admin
			from polls.models import Question


			class QuestionAdmin(admin.ModelAdmin):
				fields = ['pub_date', 'question_text']

			admin.site.register(Question, QuestionAdmin)

By default, It was showing like -- Question text:
								   Date published:

Now, I've changed the behaviour of it like --
									Question text:
									Date published:

I can also put a header like section by introducing the fieldsets in them like:
			class QuestionAdmin(admin.ModelAdmin):
				fieldsets = [(None, {'fields':['question_text']}),
							 ('Date Information', {'fields':['pub_date']}),]

If I want that some of the models should only be seen when they're clicked then We can also do by having collapse method in the fieldset.

	polls/admin.py

			from django.contrib import admin
			from polls.models import Question


			class QuestionAdmin(admin.ModelAdmin):
				fieldsets = [
					(None,               {'fields': ['question_text']}),
					('Date information', {'fields': ['pub_date'], 'classes': ['collapse']}),
				]

			admin.site.register(Question, QuestionAdmin)

Some database commnds that we'll use to reflect these questions and choices onto the admin panel.
			>>> from polls.models import Question, Choice
			>>> Question.objects.all()
			>>> Question.objects.filter(id=1)
			>>> Question.objects.filter(question_text__startswith='What')
			>>> from django.utils import timezone
			>>> current_year = timezone.now().year
			>>> Question.objects.get(pub_date__year=current_year)
			>>> Question.objects.get(id=2)
			>>> Question.objects.get(pk=1)
			>>> q = Question.objects.get(pk=1)
			>>> q.was_published_recently()
			>>> q = Question.objects.get(pk=1)
			>>> q.choice_set.all()
			>>> q.choice_set.create(choice_text='Not much', votes=0)
			>>> q.choice_set.create(choice_text='The sky', votes=0)
			>>> c = q.choice_set.create(choice_text='Just hacking again', votes=0)
			>>> c.question
			>>> q.choice_set.all()
			>>> q.choice_set.count()
			>>> Choice.objects.filter(question__pub_date__year=current_year)
			>>> c = q.choice_set.filter(choice_text__startswith='Just hacking')
			>>> c.delete()


<SERIALIZERS>
	We'll get the model object when we do filter on queryset, In case We want the data in proper format, We use serializer to convert it into JSON like format and distribute it across applications. Class meta will be defining what all the serialized fields you want.

<VERBOSE>
	When we define a model, The column will be created by the name we define the variable, If I want to save the column name with diffrent name then verbose name will be used, and The table will be crated with the column name defined as verbose name.


<CELERY>
	The purpose of celery is to allow you to run some code later, or regularly according to a schedule.
Another common situation is wanting to run some code regularly. For example, maybe every hour you want to look up the latest weather report and store the data. You can write a task to do that work, then ask Celery to run it every hour.

A Task is just a Python function.
When a task is ready to be run, Celery puts it into queue.
In case of Celery, 	Brokers are:
	RabbitMQ
	Redis
	Using database

Celery requires a solution to send and to receive messages, comes in separate services as: Message Broker
Celery is on the Python Package Index
Let's create the file tasks.py
	from celery import Celery
	app = Celery('tasks', broker='amqp://guest@localhost//')
	@app.task
	def add(x, y):
		return x + y

	The first argument in the celery is the name of the current module.
	The second argument in the celery is the name of the message broker that we'll use.

	amqp://localhost -- RabbitMQ broker
	redis://localhots -- Redis broker

App name will be the heading in admin panel, class name in models.py file will be sub heading and varibles in models.py/class will be the attribute names under subheading panel in admin.py and what all the variables I want to see in admin panel will be mentioned in admin.py file. What all the variables in list_display list will be shown into admin panel of Django Administration site.


	class BlogPost(models.Model):
		title = models.CharField(max_length=150)
		body = models.TextField()
		time_stamp = models.DateTimeField()

All the three attributes will be shown in admin panel, If I want to show only 2 attributes in admin panel, then It can be done as:


	class BlogPostAdmin(admin.ModelAdmin):
		list_display = ('title', 'timestamp')

	admin.site.register(BlogPost, BlogPostAdmin)

The admin site has been prepared and now We can start working on website.It has 3 three components.

	Templates
	View
	URL

Templates wil be diplaying the information passed to it.
Vew will be fetching the information to be displayed.
URL pattern will be matching an incoming request with view function.

When Django processes a request, it starts with the URL patterns, calls the view, and then returns the data rendered into template.

	mysite/blogs/template/archive.html

	{% for post in posts %}
	<h2>{{ post.title }}</h2>
	<p>{{ post.timestamp }}</p>
	<p>{{ post.body }}</p>
	{% endfor %}

Now the template is ready to display all the stuff received in posts. But what data it will display???
That we'll send after fetching from views.py.

	from django.template import loader, Context
	from django.http import HttpResponse
	from mysite.blog.models import BlogPost
	def archive(request):
		posts = BlogPost.objects.all()
		t = loader.get_template("archive.html")
		c = Context({ 'posts': posts })
		return HttpResponse(t.render(c))

<URL PATTTERNS>
	In urls.py file, uncomment the predifined line and modify it like as:

	url(r'^blog/', include('mysite.blog.urls')),

It'll catch any requests that begin with blog/ and passes them to a new URLconf you're about to create.

To work with templates, We'll create base.html and will be extending this base.html to other child html pages.
The basic design for base.html page will be like this:

	<html>
	<style type="text/css">
	body { color: #efd; background: #453; padding: 0 5em; margin: 0 }
	h1 { padding: 2em 1em; background: #675 }
	h2 { color: #bf8; border-top: 1px dotted #fff; margin-top: 2em }
	p { margin: 1em 0 }
	</style>
	<body>
	<h1>mysite.example.com</h1>
	{% block content %}
	{% endblock %}
	</body>
	</html>

The child HTML page will be like this:
	{% extends "base.html" %}
	{% block content %}
	{% for post in posts %}
	<h2>{{ post.title }}</h2>
	<p>{{ post.timestamp }}</p>
	<p>{{ post.body }}</p>
	{% endfor %}
	{% endblock %}

If we want to cutomize the fields of models or some class then we can import and then can change it -- easy task
What If all the classes needs the customized value, then it won't be good to import and change in every class. So we use the meta class, After defining it in meta classes, what all the values will import, will have the customized value,
	For eg:
	class meta:
		ordering = ('-timestamp', )

<COMMUNICATION - HTTP, URLs, Requests, Reponse>
	HTTP - protocol for client-server communication
